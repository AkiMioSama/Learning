# IO

[文档](https://github.com/apache/incubator-brpc/blob/master/docs/cn/io.md)

dispatcher在event_dispatcher.h中

当新的连接出现的时候，dispatcher就负责将fd分发给bthread

epoll out在我们可以向对端写入数据的时候会触发

epoll in则是在对端有数据写入时会触发。触发一次后需要不断的读取所有数据直到EAGAIN为止。

EPOLLIN connection arrives; data is coming; The associated file is available for read operations

EPOLLOUT has data to write. The associated file is available for write operations

当收到epoll in的时候，我们就调用Socket::StartInputEvent

当收到epoll out的时候，我们就调用Socket::HandleEpollOut

```cpp
int Socket::StartInputEvent(SocketId id, uint32_t events,
                            const bthread_attr_t& thread_attr) {
    SocketUniquePtr s;
    if (Address(id, &s) < 0) {
        return -1;
    }
    if (NULL == s->_on_edge_triggered_events) {
        // Callback can be NULL when receiving error epoll events
        // (Added into epoll by `WaitConnected')
        return 0;
    }
    if (s->fd() < 0) {
        CHECK(!(events & EPOLLIN)) << "epoll_events=" << events;
        return -1;
    }

    // if (events & has_epollrdhup) {
    //     s->_eof = 1;
    // }
    // Passing e[i].events causes complex visibility issues and
    // requires stronger memory fences, since reading the fd returns
    // error as well, we don't pass the events.
    if (s->_nevent.fetch_add(1, butil::memory_order_acq_rel) == 0) {
        // According to the stats, above fetch_add is very effective. In a
        // server processing 1 million requests per second, this counter
        // is just 1500~1700/s
        g_vars->neventthread << 1;

        bthread_t tid;
        // transfer ownership as well, don't use s anymore!
        Socket* const p = s.release();

        bthread_attr_t attr = thread_attr;
        attr.keytable_pool = p->_keytable_pool;
        if (bthread_start_urgent(&tid, &attr, ProcessEvent, p) != 0) {
            LOG(FATAL) << "Fail to start ProcessEvent";
            ProcessEvent(p);
        }
    }
    return 0;
}
```

当一个epoll in事件发生时，我们会通过socket id获得socket。如果没有触发事件的话直接返回就行。

由于一个socket对应的fd会不断的发生事件，我们需要保证一个socket的fd在同一时间只能被一个bthread处理。这里是在socket内部记录了_nevent，只有当从0跳到1的时候才会开一个新的bthread处理事件，其他情况下说明已经有bthread在处理了，我们直接返回就好。

这里的启动用的是bthread_start_urgent，即快速启动，他会让当前的pthread直接开始运行这个bthread，后续的部分（即dispatcher的后面的处理）则会被放到调度器中被其他的bthread偷走执行。即continuation stealing，对缓存更友好。

但是如果启动新的bthread失败的话，我们就直接在本地线程执行。

我们这里会将socket的所有权转移给新的bthread。并调用对应的回调

在Acceptor中有对应的设置。我们在这里使用的是Acceptor::OnNewConnections

```cpp
void Acceptor::OnNewConnections(Socket* acception) {
    int progress = Socket::PROGRESS_INIT;
    do {
        OnNewConnectionsUntilEAGAIN(acception);
        if (acception->Failed()) {
            return;
        }
    } while (acception->MoreReadEvents(&progress));
```

可以看到思路就是不断读取数据直到EAGAIN，对应应该是读取结束。然后再去查看是否有更多的读取事件

在OnNewConnectionUntilEAGAIN内部，首先通过accept建立连接

对于这个新的fd，我们会创建一个新的Socket来代表这个连接。并注册新的回调函数

```cpp
SocketId socket_id;
SocketOptions options;
options.keytable_pool = am->_keytable_pool;
options.fd = in_fd;
butil::sockaddr2endpoint(&in_addr, in_len, &options.remote_side);
options.user = acception->user();
options.on_edge_triggered_events = InputMessenger::OnNewMessages;
options.initial_ssl_ctx = am->_ssl_ctx;
if (Socket::Create(options, &socket_id) != 0) {
    LOG(ERROR) << "Fail to create Socket";
    continue;
}
in_fd.release(); // transfer ownership to socket_id
```

新的回调函数是InputMessenger::OnNewMessages

从这里可以大概看出来，我们对于一个server fd来说，会有一个bthread在这里不断的accept，创建新的socket。

然后后续的读入则会在InputMessenger中处理。则是由其他的bthread负责。

