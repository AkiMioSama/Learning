# bthread_id

这里的bthread id不是标识bthread的identifier，而是用于同步的一种数据结构

![20220615170433](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220615170433.png)

我们之前在channel中看到过他，用来做同步的brpc

brpc中也有相关的[文档](https://github.com/apache/incubator-brpc/blob/master/docs/cn/bthread_id.md)

![20220615170653](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220615170653.png)

这么看他的名字叫rpc id更合适一些

这里粘一下文档的东西

bthread_id包括两部分，一个是用户可见的64位id，另一个是对应的不可见的bthread::Id结构体。用户接口都是操作id的。从id映射到结构体的方式和brpc中的其他结构类似：32位是内存池的位移，32位是version。前者O(1)时间定位，后者防止ABA问题。

bthread_id的接口不太简洁，有不少API：

* create
* lock
* unlock
* unlock_and_destroy
* join
* error

这么多接口是为了满足不同的使用流程。

* 发送request的流程：bthread_id_create -> bthread_id_lock -> ... register timer and send RPC ... -> bthread_id_unlock
* 接收response的流程：bthread_id_lock -> ..process response -> bthread_id_unlock_and_destroy
* 异常处理流程：timeout/socket fail -> bthread_id_error -> 执行on_error回调(这里会加锁)，分两种情况
  * 请求重试/backup request： 重新register timer and send RPC -> bthread_id_unlock
  * 无法重试，最终失败：bthread_id_unlock_and_destroy
* 同步等待RPC结束：bthread_id_join

为了减少等待，bthread_id做了一些优化的机制：

* error发生的时候，如果bthread_id已经被锁住，会把error信息放到一个pending queue中，bthread_id_error函数立即返回。当bthread_id_unlock的时候，如果pending queue里面有任务就取出来执行。
* RPC结束的时候，如果存在用户回调，先执行一个bthread_id_about_to_destroy，让正在等待的bthread_id_lock操作立即失败，再执行用户回调（这个可能耗时较长，不可控），最后再执行bthread_id_unlock_and_destroy

通过上面使用的例子我们可以看出来，我们通过lock和unlock来做互斥。在发送或者接受数据的时候，先lock住bthread id，然后执行逻辑。这样可以防止出现数据竞争的问题。（看起来就像一个mutex，加上了错误处理以及join的功能）

然后我们看代码他是怎么实现的

