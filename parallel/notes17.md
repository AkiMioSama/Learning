![20220108115110](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108115110.png)

一个最简单的sorted linked list上的插入和删除

但是不适用于多线程，不可重入的

添加多线程支持的最简单的方法就是为这个数据结构加一个锁

同时只允许一个线程进入到代码中

但是粒度过大，并发度不高

![20220108115254](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108115254.png)

细粒度的实现

思路和数据库中的并发B树的latch crabbing protocol一样

我们在遍历的过程中，要先拿到前一个节点的锁，才能走到下一个节点并获得下一个节点的锁。然后才能释放前一个节点的锁

就像是monkey bar一样，一个手抓住，第二个手也抓住了以后才能释放第一个手

这样可以保证我们操作的值都是有效的

具体的在实现中，可以看到代码里对list也有一个锁，这是因为在最开始的时候我们要获得表头，但是要注意的是我们相当于直接抓住了表头的这个节点，但是我们并没有一个手抓住之前的节点。

这里的list的锁就是相当与head之前的一个虚拟节点让我们抓住，也可以理解成是为了保护表头而设置的单独的一个lock

同时，由于链表的特性，我们也要保证在修改一个节点的时候，要拿到这个节点和他的前一个节点的锁

代码中有个有问题的点是，我们需要拿到当前点的锁才能读下一个节点的地址，但是这一点在表头处没有处理好

考虑这样一种情景，第一个线程要删除第二个节点，所以拿到了第一个锁和第二个锁

第二个线程读到了prev和cur，然后第一个线程释放了cur的内存。这时第一个线程的cur就会是指向一个被释放的内存处

有一个优化是如果我们有当前节点的锁，那么我们可以保证接下来的节点是不会被删除的，虽然指针可能变化。

但是我们可以确定值是不会变的，所以我们可以延迟锁的时机，当要修改节点的时候再锁，读值不需要

还有一个优化是用读写锁，而非互斥锁

![20220108141915](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108141915.png)

blocking的算法就是允许一个线程阻塞其他所有的线程，当一个获得锁的线程被OS暂停时，其他的线程也就不能继续往下走

![20220108142034](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108142034.png)

而与之对应的则是lock-free的算法，他能够保证正在运行的线程可以make progress，而不会被休眠的线程阻塞

![20220108142334](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108142334.png)

最基础的实现，在添加节点的时候，用CAS原子指令来检测过程中是不是有其他的线程修改了我们需要的数据

其实相当与之前课上说的用CAS实现一些操作，这里就是修改新节点的值和指针，然后用CAS判断原节点是不是没变，然后利用CAS将结果写回

但是这会遇到ABA问题，因为我们只是简单的比较了指针的值，有可能在这个过程中其他的线程复用了这个指针的值，但是指针指向的节点已经改变了

![20220108142705](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108142705.png)

通过记录pop的数量来防止ABA问题的发生，这需要机器支持额外的指令。比如双字的CAS，才能保证我们同时对原指针和pop-count进行CAS

还有一个问题就是我们pop的时候，需要首先获得原始的栈顶，然后判断是否为空，再获取第二个元素作为新的栈顶。在这个过程中，可能我们在获取新的栈顶的时候，原本的栈顶已经被delete掉了

在GC的语言中，这是没问题的，因为我们这个线程对这个对象有引用，所以这个对象不会被删除

但是在C语言中，在其他线程中可能就已经delete掉这个元素了，不会进行判断

![20220108143724](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108143724.png)

用hazard pointer，我们每次删除节点的时候，将他放入到retireList中

当retireList值较多的时候，我们进行删除（有点类似GC）

但是删除的时候，判断每个节点是不是存在于其他线程的hazard pointer中

但是实现这个判断过程也需要一定的trick，因为这是一个多人读，一个人写的过程

难不成要用R/W lock？

![20220108144205](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108144205.png)

为什么lock free

比如我们在临界区的时候，出现了page-fault，阻塞了大量了线程

或者在临界区崩溃等问题

![20220108144344](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220108144344.png)

lock free就是为了去避免lock出现的开销（以及上面提到的问题）

而且lock free仍然需要类似lock中的memory fence来保证内存的一致性

他并不会缓解竞争，所以具体的使用还是要根据情况决定