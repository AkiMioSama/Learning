# SSTable

每次minor compaction都会生成新的sstable，major compaction会将若干个sstable合并成一个大的sstable。

这次我们看一下sstable的读写过程。参考文章在[这里](https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html#section-4)

一个sstable文件按照块划分，用来提高读写效率。每个块的大小为4kb，每个block中除了存储数据还有压缩类型以及校验码

![20220620203116](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620203116.png)

sstable中不同的block有不同的功能

![20220620203145](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620203145.png)

## data block

由于leveldb是按序存储，所以我们会使用类似前缀压缩的技术。不同的是每若干个键后我们会重头存储一个完整的键，并称为restart point

![20220620203436](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620203436.png)

这样我们可以在restart point上进行比较，从而快速定位需要的数据块。然后顺序遍历并解压缩数据

![20220620204113](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620204113.png)

![20220620204742](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620204742.png)

看一下代码。结构内部很简单，就是data以及size，owned表示我们是否拥有这个数据，是的话释放的时候就要delete掉这块数据。restart offset就是 上面图中的restart point数据的起点。

![20220620204901](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620204901.png)

检查一下restart point的有效性。然后计算restart offset。每个restart point以及最后的length都是uint32。乘起来计算一下偏移量就行。

读取block的方法就是通过iterator来。所以只提供了NewIterator

具体的实现在`block.cc`中。继承的Iterator

由于SSTable是不可变的，所以我们可以随意存储data pointer

![20220620205408](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220620205408.png)

为了减少indirection，我们就直接把`data_`和一些必要的信息存在Iterator中了

