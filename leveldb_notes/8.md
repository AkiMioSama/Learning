# SSTable(3) Read & Write

参考文档在[这里](https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html)

![20220703090700](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703090700.png)

还是看这个图。footer是固定的，通过footer去找到meta index block和index block

meta index block指向filter block，为什么不直接让footer指向filter block呢？因为meta index block中存储了filter的名字，是变长的。而footer是定长的。所以增加了一个额外的indirection

代码中主要是在table builder做写操作

table builder中有个rep的结构，用来存储各种数据

![20220703103809](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703103809.png)

主要就是这几个block builder。

![20220703104238](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703104238.png)

接口主要就是Add和Finish。在Add内部会调用Flush来构建新的块

![20220703160313](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703160313.png)

add的作用就是直接在data block中add一个kv pair。如果有filter block的话就也加入到filter中

然后当data block过大了，就调用flush

![20220703160553](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703160553.png)

flush的逻辑就是写入data block，然后创建新的bloom filter

而write block的作用主要是调用BlockBuilder的Finish，结束Block的构建，然后将这个block压缩，并写入到文件中

这里flush会设置pendng index entry为true，下一次再插入数据的时候，就会在index block中插入last key，也就是插入上个block的最大key，作为索引项。至于为什么要在下一次插入的时候再去插入index，与这个FindShortestSeparator有关。之后去研究一下

而在最后的Flush中，我们会构建上面图中的其他块

![20220703161035](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703161035.png)

开始Flush一下，把之前剩下的写入到data block中

然后将写入filter block，并写入meta index block

![20220703163547](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220703163547.png)

然后会再次插入最后的索引项。并把index block写入到sstable中。

并最后写入定长的footer。完成sstable的写入

有关一些特殊的变量，比如pending handle。他的作用是记录上次写入的data block的位置。这里的BlockHandle就是指向文件中的一块位置，也就是data block的指针。在插入索引项的时候，就会将这个指针作为value插入进去。

可以发现leveldb通过BlockBuilder来抽象这些kv表示的block。不只是data block中有restart point，在index block中restart point也是存在的。我们第一层先找到index block，然后根据restart point去找index，再根据index找到data block，从data block中的restart point去找key，最后再去遍历查找。有点高层的btree的感觉。